// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package pgdb

import (
	"context"
	"database/sql"
)

const getImprovementByID = `-- name: GetImprovementByID :one
SELECT id, name, description, state_code, living_area, value, property_id FROM improvements
WHERE id = $1 limit 1
`

func (q *Queries) GetImprovementByID(ctx context.Context, id int32) (Improvement, error) {
	row := q.db.QueryRowContext(ctx, getImprovementByID, id)
	var i Improvement
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StateCode,
		&i.LivingArea,
		&i.Value,
		&i.PropertyID,
	)
	return i, err
}

const getImprovementDetail = `-- name: GetImprovementDetail :one
SELECT id, improvement_id, improvement_type, description, class, exterior_wall, year_built, square_feet FROM improvement_detail
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetImprovementDetail(ctx context.Context, id int32) (ImprovementDetail, error) {
	row := q.db.QueryRowContext(ctx, getImprovementDetail, id)
	var i ImprovementDetail
	err := row.Scan(
		&i.ID,
		&i.ImprovementID,
		&i.ImprovementType,
		&i.Description,
		&i.Class,
		&i.ExteriorWall,
		&i.YearBuilt,
		&i.SquareFeet,
	)
	return i, err
}

const getImprovementDetails = `-- name: GetImprovementDetails :many


SELECT id, improvement_id, improvement_type, description, class, exterior_wall, year_built, square_feet FROM improvement_detail
WHERE improvement_id = $1
`

// query.sql
func (q *Queries) GetImprovementDetails(ctx context.Context, improvementID sql.NullInt32) ([]ImprovementDetail, error) {
	rows, err := q.db.QueryContext(ctx, getImprovementDetails, improvementID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ImprovementDetail
	for rows.Next() {
		var i ImprovementDetail
		if err := rows.Scan(
			&i.ID,
			&i.ImprovementID,
			&i.ImprovementType,
			&i.Description,
			&i.Class,
			&i.ExteriorWall,
			&i.YearBuilt,
			&i.SquareFeet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImprovementsByPropertyID = `-- name: GetImprovementsByPropertyID :many
SELECT id, name, description, state_code, living_area, value, property_id FROM improvements
WHERE property_id = $1 limit 1
`

func (q *Queries) GetImprovementsByPropertyID(ctx context.Context, propertyID sql.NullInt32) ([]Improvement, error) {
	rows, err := q.db.QueryContext(ctx, getImprovementsByPropertyID, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Improvement
	for rows.Next() {
		var i Improvement
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StateCode,
			&i.LivingArea,
			&i.Value,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJurisdictionsByPropertyID = `-- name: GetJurisdictionsByPropertyID :many
SELECT id, entity, description, tax_rate, appraised_value, taxable_value, estimated_tax, property_id FROM jurisdictions
WHERE property_id = $1
`

func (q *Queries) GetJurisdictionsByPropertyID(ctx context.Context, propertyID sql.NullInt32) ([]Jurisdiction, error) {
	rows, err := q.db.QueryContext(ctx, getJurisdictionsByPropertyID, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Jurisdiction
	for rows.Next() {
		var i Jurisdiction
		if err := rows.Scan(
			&i.ID,
			&i.Entity,
			&i.Description,
			&i.TaxRate,
			&i.AppraisedValue,
			&i.TaxableValue,
			&i.EstimatedTax,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandByPropertyID = `-- name: GetLandByPropertyID :many
SELECT id, number, land_type, description, acres, square_feet, eff_front, eff_depth, market_value, property_id FROM land
WHERE property_id = $1 limit 1
`

func (q *Queries) GetLandByPropertyID(ctx context.Context, propertyID sql.NullInt32) ([]Land, error) {
	rows, err := q.db.QueryContext(ctx, getLandByPropertyID, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Land
	for rows.Next() {
		var i Land
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.LandType,
			&i.Description,
			&i.Acres,
			&i.SquareFeet,
			&i.EffFront,
			&i.EffDepth,
			&i.MarketValue,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandBySize = `-- name: GetLandBySize :many
SELECT id, number, land_type, description, acres, square_feet, eff_front, eff_depth, market_value, property_id FROM land
WHERE acres >= $1
 and acres <= $2
`

type GetLandBySizeParams struct {
	Acres   sql.NullFloat64
	Acres_2 sql.NullFloat64
}

func (q *Queries) GetLandBySize(ctx context.Context, arg GetLandBySizeParams) ([]Land, error) {
	rows, err := q.db.QueryContext(ctx, getLandBySize, arg.Acres, arg.Acres_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Land
	for rows.Next() {
		var i Land
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.LandType,
			&i.Description,
			&i.Acres,
			&i.SquareFeet,
			&i.EffFront,
			&i.EffDepth,
			&i.MarketValue,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLandByType = `-- name: GetLandByType :many
SELECT id, number, land_type, description, acres, square_feet, eff_front, eff_depth, market_value, property_id FROM land
WHERE land_type = $1
`

func (q *Queries) GetLandByType(ctx context.Context, landType sql.NullString) ([]Land, error) {
	rows, err := q.db.QueryContext(ctx, getLandByType, landType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Land
	for rows.Next() {
		var i Land
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.LandType,
			&i.Description,
			&i.Acres,
			&i.SquareFeet,
			&i.EffFront,
			&i.EffDepth,
			&i.MarketValue,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPropertyByID = `-- name: GetPropertyByID :one
SELECT id, owner_id, owner_name, owner_mailing_address, zoning, neighborhood_cd, neighborhood, address, legal_description, geographic_id, exemptions, ownership_percentage, mapsco_map_id, longitude, latitude, address_number, address_line_two, city, street, county, state FROM properties
WHERE id = $1 limit 1
`

func (q *Queries) GetPropertyByID(ctx context.Context, id int32) (Property, error) {
	row := q.db.QueryRowContext(ctx, getPropertyByID, id)
	var i Property
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.OwnerName,
		&i.OwnerMailingAddress,
		&i.Zoning,
		&i.NeighborhoodCd,
		&i.Neighborhood,
		&i.Address,
		&i.LegalDescription,
		&i.GeographicID,
		&i.Exemptions,
		&i.OwnershipPercentage,
		&i.MapscoMapID,
		&i.Longitude,
		&i.Latitude,
		&i.AddressNumber,
		&i.AddressLineTwo,
		&i.City,
		&i.Street,
		&i.County,
		&i.State,
	)
	return i, err
}

const getPropertyByNeighborhood = `-- name: GetPropertyByNeighborhood :many
SELECT id, owner_id, owner_name, owner_mailing_address, zoning, neighborhood_cd, neighborhood, address, legal_description, geographic_id, exemptions, ownership_percentage, mapsco_map_id, longitude, latitude, address_number, address_line_two, city, street, county, state FROM properties
WHERE neighborhood = $1
`

func (q *Queries) GetPropertyByNeighborhood(ctx context.Context, neighborhood sql.NullString) ([]Property, error) {
	rows, err := q.db.QueryContext(ctx, getPropertyByNeighborhood, neighborhood)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.OwnerName,
			&i.OwnerMailingAddress,
			&i.Zoning,
			&i.NeighborhoodCd,
			&i.Neighborhood,
			&i.Address,
			&i.LegalDescription,
			&i.GeographicID,
			&i.Exemptions,
			&i.OwnershipPercentage,
			&i.MapscoMapID,
			&i.Longitude,
			&i.Latitude,
			&i.AddressNumber,
			&i.AddressLineTwo,
			&i.City,
			&i.Street,
			&i.County,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRollValuesByPropertyID = `-- name: GetRollValuesByPropertyID :many
Select id, year, improvements, land_market, ag_valuation, appraised, homestead_cap, assessed, property_id from roll_values
where property_id = $1
`

func (q *Queries) GetRollValuesByPropertyID(ctx context.Context, propertyID sql.NullInt32) ([]RollValue, error) {
	rows, err := q.db.QueryContext(ctx, getRollValuesByPropertyID, propertyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RollValue
	for rows.Next() {
		var i RollValue
		if err := rows.Scan(
			&i.ID,
			&i.Year,
			&i.Improvements,
			&i.LandMarket,
			&i.AgValuation,
			&i.Appraised,
			&i.HomesteadCap,
			&i.Assessed,
			&i.PropertyID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProperties = `-- name: ListProperties :many
Select id, owner_id, owner_name, owner_mailing_address, zoning, neighborhood_cd, neighborhood, address, legal_description, geographic_id, exemptions, ownership_percentage, mapsco_map_id, longitude, latitude, address_number, address_line_two, city, street, county, state from properties limit $1 offset $2
`

type ListPropertiesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListProperties(ctx context.Context, arg ListPropertiesParams) ([]Property, error) {
	rows, err := q.db.QueryContext(ctx, listProperties, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Property
	for rows.Next() {
		var i Property
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.OwnerName,
			&i.OwnerMailingAddress,
			&i.Zoning,
			&i.NeighborhoodCd,
			&i.Neighborhood,
			&i.Address,
			&i.LegalDescription,
			&i.GeographicID,
			&i.Exemptions,
			&i.OwnershipPercentage,
			&i.MapscoMapID,
			&i.Longitude,
			&i.Latitude,
			&i.AddressNumber,
			&i.AddressLineTwo,
			&i.City,
			&i.Street,
			&i.County,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePropertySetAddressParts = `-- name: UpdatePropertySetAddressParts :exec
Update properties set address_number = $1, address_line_two = $2, street = $3, city = $4, county = $5, state = $6
where id = $7
`

type UpdatePropertySetAddressPartsParams struct {
	AddressNumber  string
	AddressLineTwo sql.NullString
	Street         sql.NullString
	City           sql.NullString
	County         sql.NullString
	State          sql.NullString
	ID             int32
}

func (q *Queries) UpdatePropertySetAddressParts(ctx context.Context, arg UpdatePropertySetAddressPartsParams) error {
	_, err := q.db.ExecContext(ctx, updatePropertySetAddressParts,
		arg.AddressNumber,
		arg.AddressLineTwo,
		arg.Street,
		arg.City,
		arg.County,
		arg.State,
		arg.ID,
	)
	return err
}
